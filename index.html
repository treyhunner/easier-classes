<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Easier Classes: Python Classes Without All The Cruft</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Easier Classes</h1>
          <h2>Python Classes Without All The Cruft</h2>
          <p>
          <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            Alright.  Before we jump into this talk, let me quickly introduce myself.
          </aside>
        </section>

        <section>
          <div class="aboutme-card">
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos" alt="Truthful Technology"></a>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonmorsels.com"><img src="morsels-logo.svg" class="no-style aboutme-logos" alt="Python Morsels"></a>
          </div>
          <aside class="notes" data-markdown>
            - My name is Trey
            - I help Python &amp; Django teams on-board new teammates and turn their front-end developers into full-stack Django developers.
            - And I run a Python exercise subscription service where where I send out 1 Python exercise every week.  It's called Python Morsels.
            - Let's talk about classes.
          </aside>
        </section>

      </section>

      <section>
        <h3 class="fragment strike" data-fragment-index=1>Pythonic Classes</h3>
        <h2 class="fragment" data-fragment-index=1>Friendly Classes</h2>
        <ul>
          <li class="fragment">have nice string representations</li>
          <li class="fragment">can be compared to each other</li>
          <li class="fragment">embrace operator overloading</li>
        </ul>
        <aside class="notes" data-markdown>
          - I'd like to talk about making classes that are easy for developers to use
          - I'm tempted to use the phrase Pythonic classes to describe this idea, but that word Pythonic is a bit loaded, so I'm going to instead say that we're making **friendly** classes
          - Friendly classes are friendly for the developers who use them
          - They have a nice string representation
          - They can be compared to each other in ways that make sense
          - And whenever it makes, they overload operators to allow themselves to be addable, iterable, hashable on so on
        </aside>
      </section>

      <section>

      <section>
        <h1>Example: a Month class</h1>
      </section>

      <section>
        <h2><span class="fragment" data-fragment-index=5>Comparability</span> <span class="fragment" data-fragment-index=9>and Orderability</span></h2>
        <div class="container">
        <pre class="col python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>m = Month(2018, 6)
>>> </span><span class="fragment" data-fragment-index=3>m
Month(year=2018, month=6)
>>> </span><span class="fragment" data-fragment-index=6>m == Month(2018, 6)
True
>>> </span><span class="fragment" data-fragment-index=7>m != Month(2018, 6)
False
>>> </span><span class="fragment" data-fragment-index=10>m &lt; Month(2018, 12)
True
>>> </span><span class="fragment" data-fragment-index=12>m > Month(2019, 1)
False
>>> </span><span class="fragment" data-fragment-index=14>m &lt;= Month(2018, 12)
True
>>> </span><span class="fragment" data-fragment-index=16>m >= Month(2018, 6)
True</span>
        </code></pre>
        <pre class="col python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index=2>class Month:
    def __init__(self, year, month):
        pass</span>
    <span class="fragment" data-fragment-index=4>def __repr__(self):
        pass</span>
    <span class="fragment" data-fragment-index=8>def __eq__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=11>def __lt__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=13>def __gt__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=15>def __le__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=17>def __ge__(self, other):
        pass</span>
        </code></pre>
        </div>
        <aside class="notes" data-markdown>
          - If you want a class in Python that accepts attributes, you'll probably want an initializer
          - If you want it to have a helpful string representation, you'll also want a dunder repr method
          - But what if you also wanted your classes to be comparable to other classes?... using equality and inequality?
          - In that case you'll want a dunder eq method.
          - If you wanted to go further, by allowing your classes to be sortable, you'll need to implement the less than operator with dunder lt, the greater than operator with dunder gt, the less than or equal to operator with dunder le, and the greater than or equal to operator with dunder ge
          - After all this, our class is going to look pretty big
        </aside>
      </section>

      <section>
        <pre class=""><code data-trim data-noescape>
class Month:
    def __init__(self, year, month):
        self.year, self.month = year, month
    def __repr__(self):
        return f"Month(year={self.year}, month={self.month})"
    def <span class="fragment bold" data-fragment-index=1>__eq__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>==</span> (other.year, other.month)
    def <span class="fragment bold" data-fragment-index=1>__lt__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>&lt;</span> (other.year, other.month)
    def <span class="fragment bold" data-fragment-index=1>__gt__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>&gt;</span> (other.year, other.month)
    def <span class="fragment bold" data-fragment-index=1>__le__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>&lt;=</span> (other.year, other.month)
    def <span class="fragment bold" data-fragment-index=1>__ge__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>&gt;=</span> (other.year, other.month)</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - You might notice there's a lot of code duplication here
          - All five of those comparison dunder methods are pretty much the same method
          - The only real difference is the operator they use
          - There is a helper in the standard library to make this class a bit shorter
        </aside>
      </section>

      <section>
        <pre class=""><code data-trim data-noescape>
from functools import total_ordering


@total_ordering
class Month:
    def __init__(self, year, month):
        self.year, self.month = year, month
    def __repr__(self):
        return f"Month(year={self.year}, month={self.month})"
    def __eq__(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) == (other.year, other.month)
    def __lt__(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) &lt; (other.year, other.month)
        </code></pre>
        <aside class="notes" data-markdown>
          - It's called `total_ordering` and it lives in the `functools` module
          - It allows us to implement just 2 comparison operators and it'll implement the others automatically
          - But there's still a lot of boilerplate code needed for this class
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>Example: a Point class</h1>
      </section>

      <section>
        <h2><span class="fragment" data-fragment-index=5>Iterability</span> <span class="fragment" data-fragment-index=7>and Immutability</span></h2>
        <div class="container">
        <pre class="col python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>p = Point(1, 2, 3)
>>> </span><span class="fragment" data-fragment-index=2>p
Point(x=1, y=2, z=3)
>>> </span><span class="fragment" data-fragment-index=3>p == Point(1, 2, 3)
True
>>> </span><span class="fragment" data-fragment-index=4>x, y, z = p
>>> </span><span class="fragment" data-fragment-index=8>p.x = 4
Traceback (most recent call last):
  File "&lt;stdin>", line 1
  File "&lt;string>", line 3
AttributeError: object is immutable
>>> </span><span class="fragment" data-fragment-index=12>{Point(1, 2, 3), Point(1, 2, 3)}
{Point(x=1, y=2, z=3)}</span>
        </code></pre>
        <pre class="col python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index=1>class Point:
    def __init__(self, x, y, z):
        pass</span>
    <span class="fragment" data-fragment-index=2>def __repr__(self):
        pass</span>
    <span class="fragment" data-fragment-index=3>def __eq__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=6>def __iter__(self):
        pass</span>
    <span class="fragment" data-fragment-index=9>def __setattr__(self, name, value):
        pass</span>
    <span class="fragment" data-fragment-index=13>def __hash__(self):
        pass</span>
        </code></pre>
        </div>
        <aside class="notes" data-markdown>
          - Just as in our last example, we're going to want our class to accept arguments, have a nice string representation, and allow itself to be compared to other `Point` objects
          - But what if we also want to allow our class to be unpacked into three coordinate variables using multiple assignment?
          - Multiple assignment requires that our class be iterable
          - We'll need a dunder iter method for that
          - We might also want our class to be immutable, meaning we can't override any of the attributes after we've created a `Point` object
          - For this we need to make a custom dunder setattr method
          - And if our class is immutable it should be safe to use it in dictionary keys and sets
          - But we'll need a dunder hash method for that
          - So after all of this work, our `Point` class ends up looking something like this...
        </aside>
      </section>

      <section>
        <pre class=""><code data-trim data-noescape>
class Point:
    def __init__(self, x, y, z):
        self.x, self.y, self.z = x, y, z
    def __repr__(self):
        return f"Point(x={self.x}, y={self.y}, z={self.z})"
    def __eq__(self, other):
        if not isinstance(other, Point):
            return NotImplemented
        return tuple(self) == tuple(other)
    def __iter__(self):
        yield from (self.x, self.y, self.z)
    def __setattr__(self, attribute, value):
        raise AttributeError("object is immutable")
    __delattr__ = __setattr__
    def __hash__(self):
        return hash(tuple(self))
        </code></pre>
        <aside class="notes" data-markdown>
          - This class does quite a bit without too many lines of code
          - But most of this code is pretty standard and is basically boilerplate code
          - And we can actually get all of this functionality for free...
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>namedtuple</h1>
        <aside class="notes" data-markdown>
          - By using the `namedtuple` helper function from the Python standard library
        </aside>
      </section>

      <section>
        <pre class="python fragment"><code data-trim data-noescape>
from collections import namedtuple

<span class="fragment">Point = namedtuple('Point', ['x', 'y', 'z'])</span>
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment">p
Point(x=1, y=2, z=3)
>>> </span><span class="fragment">p == Point(1, 2, 3)
True
>>> </span><span class="fragment">p.x = 4
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AttributeError: cannot set attribute
>>> </span><span class="fragment">{p, p}
{Point(x=1, y=2, z=3)}</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - The `namedtuple` function lives in the `collections` module
          - `namedtuple` isn't a class so much as a factory function that creates new classes
          - When you call `namedtuple`, you pass it in the name of the class and the attributes the class should have, and it'll dynamically create a new class for you
          - The classes created by `namedtuple` have a friendly string representation
          - They can be compared to each other
          - And they're immutable, and hashable, just like tuples
          - If you find it unintuitive that calling `namedtuple` gives you a class back, you can use a nicer syntax for creating named tuples...
        </aside>
      </section>

      <section>
        <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
from typing import NamedTuple

class Point(NamedTuple):
    x: float <span class="fragment current-visible" data-fragment-index=3>= 0</span>
    y: float <span class="fragment current-visible" data-fragment-index=3>= 0</span>
    z: float <span class="fragment current-visible" data-fragment-index=3>= 0</span><span class="fragment" data-fragment-index=4></span>
        </code></pre>
        <pre class="python fragment" data-fragment-index=2><code data-trim data-noescape>
from collections import namedtuple

Point = namedtuple('Point', ['x', 'y', 'z'])
        </code></pre>
        <aside class="notes" data-markdown>
          - Since Python 3.5, you've been able to use the `NamedTuple` class from the `typing` module to do the same thing
          - It has the added benefit of using type hints for your code to document what it does
          - Outside of those type hints, this is essentially equivalent to the old fashion way of making name tuples
          - Except that you can also specify default values for your attributes, which can be pretty handy in some cases
          - although... it doesn't make much sense in this example
          - *(pause)*
          - In general named tuples are a great replacement for tuples
          - But sometimes they're more hassle than they're worth...
        </aside>
      </section>

      <section>
        <h2>named<span class="fragment bold">tuple</span> are tuples</h2>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">p &lt; Point(4, 5, 6)
True
>>> </span><span class="fragment">p + Point(4, 5, 6)
(1, 2, 3, 4, 5, 6)
>>> </span><span class="fragment">p * 2
(1, 2, 3, 1, 2, 3)
>>> </span><span class="fragment">len(p)
3</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - Named tuples inherit from tuples
          - Which means they inherit all the features that tuples have
          - So they can be ordered... which can be useful but sometimes it doesn't make sense
          - They can also be added to each other... and you get a tuple back when you do that
          - Which is a little weird
          - And they can be multiplied by integers to make other tuples also... which is also pretty odd
          - Also they have length... which doesn't necessarily make sense in all cases
          - So named tuples can be useful, but you sometimes have to be careful while using them
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
from typing import NamedTuple

class Point(NamedTuple):
    x: float
    y: float
    z: float
    def __lt__(self, other): raise TypeError
    def __le__(self, other): raise TypeError
    def __gt__(self, other): raise TypeError
    def __ge__(self, other): raise TypeError
    def __add__(self, other): raise TypeError
    def __mul__(self, other): raise TypeError
    def __rmul__(self, other): raise TypeError
    def __len__(self, other): raise TypeError
        </code></pre>
        <aside class="notes" data-markdown>
          - You can fix these problems by overloading the appropriate operators in your named tuple class
          - But finding and removing features that you don't want is often trickier than adding features that you do want
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>attrs</h1>
        <aside class="notes" data-markdown>
          - Another solution is to use a third-party library called attrs
        </aside>
      </section>

      <section>
        <pre class="bash fragment"><code data-trim data-noescape>
$ pip install attrs
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
import attr

@attr.s(auto_attribs=True)
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment">p
Point(x=1, y=2, z=3)
>>> </span><span class="fragment">p == Point(1, 2, 3)
True
>>> </span><span class="fragment">p &lt; Point(4, 5, 6)
True</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - You can get attrs by pip-installing it
          - After that you can use it by importing attr (without the s, which is a little odd)
          - That `auto_attribs` argument allows us to use the type hints to define our attributes
          - By default, `attrs` classes get a nice string representation
          - And they can be logically compared to other objects of the same type
          - But they can also be ordered based on those objects, which is a bit odd in this case
        </aside>
      </section>

      <section>
        <pre class="python fragment" data-fragment-index=0><code data-trim data-noescape>
import attr

@attr.s(auto_attribs=True, <span class="fragment bold-current" data-fragment-index=3>cmp=False</span>, <span class="fragment bold-current" data-fragment-index=1>frozen=True</span>)
class Point:
    x: float
    y: float
    z: float
    <span class="fragment bold-current" data-fragment-index=2>def __iter__(self):
        yield from (self.x, self.y, self.z)</span>
    <span class="fragment bold-current" data-fragment-index=4>def __eq__(self, other):
        if not isinstance(other, Point):
            return NotImplemented
        return tuple(self) == tuple(other)</span>
    <span class="fragment bold-current" data-fragment-index=5>def __hash__(self):
        return hash(tuple(self))</span><span class="fragment" data-fragment-index=10></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - If we want our `Point` class to work just like the one we made manually before, we could do this
          - Here we've frozen our object so the attributes can't be modified
          - We've also added a dunder iter method to make our object work with multiple assignment
          - And we've disabled comparisons so we don't get automatic ordering, but that means we need to implement a dunder eq method
          - We also need to implement the dunder hash method ourselves despite the fact that our class is frozen because disabling comparisons also disables hashing by default
          - So the attrs library is more powerful than named tuples, but it does sometimes take a bit of playing to get it just right
          - Also it's a third party library which means you'll need to install it whenever you want to use it
          - There's something similar to `attrs` that's actually bundled with Python
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>dataclasses</h1>
        <aside class="notes" data-markdown>
          - Data classes are built-in to the Python standard library and they're essentially a simplified version of the `attrs` library
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> <span class="fragment">p = Point(1, 2, 3)
>>> </span><span class="fragment">p == Point(1, 2, 3)
True
>>> </span><span class="fragment">p
Point(x=1, y=2, z=3)
>>> </span><span class="fragment">p &lt; Point(4, 5, 6)
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: '&lt;' not supported between instances of 'Point' and 'Point'</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - To use dataclasses, you'll import `dataclass` from the `dataclasses` library
          - And you'll decorate your class, the same way you can with `attrs`
          - The syntax relies on type hinting, just like `typing.NamedTuple` and `attrs` do
          - This `Point` class has a nice string representation and supports comparisons
          - And it doesn't support ordering... just as we'd expect
          - But this `Point` class isn't iterable and isn't immutable
        </aside>
      </section>

      <section data-transition="none-out" data-transition-speed="default-in fast-out">
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass<span class="fragment" data-fragment-index=2>(frozen=True)</span>
class Point:
    x: float
    y: float
    z: float
    <span class="fragment" data-fragment-index=1>def __iter__(self):
        yield from (self.x, self.y, self.z)</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - If we want our `Point` class to be iterable, we can add a dunder iter method
          - If we want our `Point` class to be immutable, we can set the `frozen` attribute when calling our `dataclass` decorator
          - There's actually an even better way to implement that dunder iter method
        </aside>
      </section>

      <section data-transition="fade-in" data-transition-speed="fast-in default-out">
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, astuple

@dataclass(frozen=True)
class Point:
    x: float
    y: float
    z: float
    def __iter__(self):
        yield from astuple(self)
        </code></pre>
        <aside class="notes" data-markdown>
          - The `astuple` helper function allows us to get a tuple representation of our object without manually specifying each attribute
        </aside>
      </section>

      <section>
        <h2>dataclasses</h2>
        <ul>
          <li class="fragment">Built-in to standard library <span class="fragment">(in Python 3.7)</span></li>
          <li class="fragment">Available as a third-party library</li>
          <li class="fragment">dataclasses is simpler, but less feature-rich than attrs</li>
          <li class="fragment">While attrs supports both Python 2 and Python 3, dataclasses only work on Python 3</li>
        </ul>
        <aside class="notes" data-markdown>
          - When I said before that dataclasses was included with Python, I meant that it's included with Python 3.7
          - Which isn't released yet, so you're probably not using it
          - However it is available as a third-party library, so you can pip-install it from any version of Python 3.  If you're on Python 2, you're out of luck.
          - If you need Python 2 support or if you need more features that dataclasses provide, you might want to reach for attrs instead
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>Data Classes Recipes</h1>
        <aside class="notes" data-markdown>
          - Let's take a look at some common uses for data classes
        </aside>
      </section>

      <section>
        <h2>What you get out of the box</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> p
Point(x=1, y=2, z=3)
>>> p == Point(1, 2, 3)
True
        </code></pre>
        <aside class="notes" data-markdown>
          - Without any other customization, data classes give you:
            - a good string representation for your object
            - and they allow you to compare objects to each other with the equality and inequality operators
        </aside>
      </section>

      <section>
        <h2>Immutability?</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment">p.x = 8
>>> </span><span class="fragment">p.x
8
>>> </span><span class="fragment">p
Point(x=8, y=5, z=3)</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - By default, dataclasses are mutable, meaning that you can change their values
          - That's often the functionality that's most useful, but if you wanted an immutable class, one that you can't change, you can do that too
        </aside>
      </section>

      <section>
        <h2>Immutability!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass<span class="fragment bold-current">(frozen=True)</span>
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment">p.x = 4
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 3, in __setattr__
dataclasses.FrozenInstanceError: cannot assign to field 'x'</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - As we've already seen, the `frozen` argument can be passed to the `dataclass` decorator to make our data classes immutable
          - This will make it so we can't assign to any of the attributes in our class after it's been constructed
        </aside>
      </section>

      <section>
        <h2>Hashability!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass(frozen=True)
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> q = Point(4, 5, 6)
>>> r = Point(1, 2, 3)
>>> <span class="fragment">points = {p, q, r}
>>> </span><span class="fragment">points
{Point(x=4, y=5, z=6), Point(x=1, y=2, z=3)}</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - As an added bonus, frozen dataclasses are also hashable by default
          - Meaning we can use our objects in sets and as dictionary keys
          - Normally dataclasses aren't hashable because it's usually a bad idea to allow mutable objects to be hashable
        </aside>
      </section>

      <section>
        <h2>Iterability?</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment">x, y, z = p
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'Point' object is not iterable</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - By default, you can't unpack a dataclass
          - If we want to use multiple assignment with dataclasses, we'll need to implement our own dunder iter method
        </aside>
      </section>

      <section>
        <h2>Iterability!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
    z: float
    def __iter__(self):
        yield self.x
        yield self.y
        yield self.z
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> x, y, z = Point(1, 2, 3)
</code></pre>
        <aside class="notes" data-markdown>
          - As we've already seen, we can do that manually by yielding x, y, and z individually
          - The dataclasses library also includes helpers to make looping over our fields easier
        </aside>
      </section>

      <section>
        <h2>Better Iterability!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, astuple

@dataclass
class Point:
    x: float
    y: float
    z: float
    def __iter__(self):
        yield from astuple(self)
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> x, y, z = Point(1, 2, 3)
>>> (x, y, z)
(1, 2, 3)
        </code></pre>
        <aside class="notes" data-markdown>
          - The `astuple` function accepts a dataclass and returns a tuple of its attribute values, in order
          - So we yield items from this tuple instead of writing each attribute out manually
        </aside>
      </section>

      <section>
        <h2>Orderability?</h2>
        <pre class=""><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Month:
    year: int
    month: int
        </code></pre>
        <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> eol_month = Month(2020, 1)
>>> eol_month
Month(year=2020, month=1)
>>> <span class="fragment">eol_month > Month(2019, 12)</span>
<span class="fragment">Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: '>' not supported between instances of 'Month' and 'Month'</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - What if we want our objects to be orderable using the less than and greater than operators?
          - By default, we can only check for equality and inequality on our classes
          - They don't support ordering automatically
        </aside>
      </section>

      <section>
        <h2>Orderability!</h2>
        <pre class=""><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass<span class="fragment bold-current">(order=True)</span>
class Month:
    year: int
    month: int
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> Month(2020, 1) > Month(2019, 12)
True
>>> months = [Month(2018, 6), Month(2018, 1), Month(2019, 10)]
>>> <span class="fragment">print(*sorted(months), sep='\n')
Month(year=2018, month=1)
Month(year=2018, month=6)
Month(year=2019, month=10)</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - But if we do want to support ordering, we can pass the `order` argument to the `dataclass` decorator when we make our class
          - Our class will be ordered lexicographically, the same way tuples, lists, and strings are ordered in Python
        </aside>
      </section>

      <section>
        <h2>Summability and other operations?</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, astuple

@dataclass
class Vector:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Vector(1, 2, 3)
>>> q = Vector(4, 5, 6)
>>> <span class="fragment">p + q
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: unsupported operand type(s) for +: 'Vector' and 'Vector'
>>> <span><span class="fragment">q - p
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: unsupported operand type(s) for +: 'Vector' and 'Vector'</span></code></pre>
        <aside class="notes" data-markdown>
          - What if you want other operations on your objects?
          - By default, dataclasses don't support the `+` operator and they don't support the `-` operator
          - If you want your classes to work with these operators, you'll have to implement that suppot yourself
        </aside>
      </section>

      <section>
        <h2>Summability and other operations!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, astuple

@dataclass
class Vector:
    x: float
    y: float
    z: float
    def __iter__(self):
        yield from astuple(self)
    def __add__(self, other):
        return Vector(*(a + b for a, b in zip(self, other)))
    def __sub__(self, other):
        return Vector(*(a - b for a, b in zip(self, other)))        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">Vector(1, 2, 3) + Vector(4, 5, 6)
Vector(x=5, y=7, z=9)
>>> </span><span class="fragment">Vector(4, 5, 6) - Vector(1, 2, 3)
Vector(x=3, y=3, z=3)</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - But if you make your classes iterable, it's not that hard
          - Here we've implemented dunder add and dunder sub methods for addition and subtraction
          - Instead of manually adding x, y, and z coordinates, we're delegating work to our dunder iter method, which is in turn delegating work to the `astuple` helper function
        </aside>
      </section>

      </section>

      <section>
        <h2>When making classes, consider...</h2>
        <ul>
          <li class="fragment">You don't always need custom classes for your data <nobr class="fragment">(see Jack Diederich's <a href="https://www.youtube.com/watch?v=o9pEzgHorH0">Stop Writing Classes</a>)</nobr></li>
          <li class="fragment">Custom can make things very handy, but they can be a step down unless you make them friendly to use</li>
          <li class="fragment">Friendly classes can require a lot of boilerplate code</li>
          <li class="fragment">To avoid distracting boilerplate code, use <code>dataclasses</code> <span class="fragment">or <code>attrs</code> for creating custom data-heavy classes</span></li>
        </ul>
        <aside class="notes" data-markdown>
          - When you're about to create a class in Python, I'd like you to consider
          - That you probably don't need a class
          - There's a talk called Stop Writing Classes that I'd highly recommend watching if you haven't seen it before
          - If you do decide you need a class, you should make it a friendly one.  Using your class should feel almost as natural as using one of the Python built-in data types
          - Creating a friendly class involves writing a lot of boilerplate code
          - But the dataclasses library can help with this
          - If you're on Python 3.7, it comes bundled with Python. If you're on an earlier version of Python 3, you can pip-install it.
          - And if dataclasses isn't enough for you, or if you need Python 2 support, there's always the attrs library
        </aside>
      </section>

      <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
        <h2>Need help getting your team <nobr>up to speed on Python?</nobr></h2>
        <h3>
          <strong>Trey Hunner</strong><br>
          <small>Python &amp; Django Team Trainer</small>
        </h3>
        <p>
          <small>
            Contact me: <a href="mailto:&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;">&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;</a>
          </small>
        </p>
        <p>
        <a href="http://truthful.technology"><img src="logo.svg" class="no-style logo"></a>
        <a href="http://pythonmorsels.com"><img src="python-morsels-logo.svg" class="no-style logo"></a>
        </p>
        <aside class="notes" data-markdown>
          - My name is Trey Hunner
          - I would love to teach Python and Django at your company
          - Feel free to shoot me an email
          - Thank you!
        </aside>
      </section>


      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/truthful.js"></script>


    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>

<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Easier Classes: Python Classes Without All The Cruft</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Easier Classes</h1>
          <h2>Python Classes Without All The Cruft</h2>
          <p>
          <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            Alright.  Before we jump into this talk, let me quickly introduce myself.
          </aside>
        </section>

        <section>
          <div class="aboutme-card">
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos" alt="Truthful Technology"></a>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonmorsels.com"><img src="morsels-logo.svg" class="no-style aboutme-logos" alt="Python Morsels"></a>
          </div>
          <aside class="notes" data-markdown>
            - My name is Trey
            - I help Python &amp; Django teams on-board new teammates and turn their front-end developers into full-stack Django developers.
            - And I run a Python exercise subscription service where where I send out 1 Python exercise every week.  It's called Python Morsels.
            - Let's talk about classes.
          </aside>
        </section>

      </section>

      <section>
        <h3 class="fragment strike" data-fragment-index=1>Pythonic Classes</h3>
        <h2 class="fragment" data-fragment-index=1>Friendly Classes</h2>
        <ul>
          <li class="fragment">have nice string representations</li>
          <li class="fragment">can be compared to each other</li>
          <li class="fragment">embrace operator overloading</li>
        </ul>
        <aside class="notes" data-markdown>
          - I'd like to talk about making classes that are easy for developers to use
          - I'm tempted to use the phrase Pythonic classes to describe this idea, but that word Pythonic is a bit loaded, so I'm going to instead say that we're making **friendly** classes **(click)**
          - Friendly classes are friendly for the developers who use them
          - Friendly classes **(click)** have a nice string representation
          - They **(click)** can be compared to each other in ways that make sense
          - And whenever it makes, they **(click)** overload operators to allow themselves to be addable, iterable, hashable on so on
        </aside>
      </section>

      <section>

      <section>
        <h1>Case 1: Month class</h1>
        <aside class="notes" data-markdown>
          Let's take a look at an example of a friendly class.
        </aside>
      </section>

      <section>
        <h2><span class="fragment" data-fragment-index=5>Comparability</span> <span class="fragment" data-fragment-index=9>and Orderability</span></h2>
        <div class="container">
        <pre class="col python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>m = Month(2018, 6)
>>> </span><span class="fragment" data-fragment-index=3>m
Month(year=2018, month=6)
>>> </span><span class="fragment" data-fragment-index=6>m == Month(2018, 6)
True
>>> </span><span class="fragment" data-fragment-index=7>m != Month(2018, 6)
False
>>> </span><span class="fragment" data-fragment-index=10>m &lt; Month(2018, 12)
True
>>> </span><span class="fragment" data-fragment-index=12>m > Month(2019, 1)
False
>>> </span><span class="fragment" data-fragment-index=14>m &lt;= Month(2018, 12)
True
>>> </span><span class="fragment" data-fragment-index=16>m >= Month(2018, 6)
True</span>
        </code></pre>
        <pre class="col python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index=2>class Month:
    def __init__(self, year, month):
        pass</span>
    <span class="fragment" data-fragment-index=4>def __repr__(self):
        pass</span>
    <span class="fragment" data-fragment-index=8>def __eq__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=11>def __lt__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=13>def __gt__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=15>def __le__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=17>def __ge__(self, other):
        pass</span>
        </code></pre>
        </div>
        <aside class="notes" data-markdown>
          - If you want a class in Python that **(click)** accepts attributes, you'll probably want **(click)** an initializer
          - If you want it to have **(click)** a helpful string representation, you'll also want **(click)** a **dunder repr** method
          - Dunder, by the way, stands for double underscore and dunder methods are special methods that provide a contract between us and Python
          - But what if you also wanted your classes to be **(click)** comparable to other classes?... using **(click)** equality and **(click)** inequality?
          - In that case you'll want **(click)** a **dunder eq** method.
          - If you wanted to go further, by allowing your classes to be **(click)** sortable, you'll need to implement **(click)** the less than operator with **(click)** **dunder lt**, **(click)** the greater than operator with **(click)** **dunder gt**, the **(click)** less than or equal to operator with **(click)** **dunder le**, and **(click)** the greater than or equal to operator with **(click)** **dunder ge**
          - After all this, our class is going to look pretty big
        </aside>
      </section>

      <section>
        <pre class=""><code data-trim data-noescape>
class Month:
    def __init__(self, year, month):
        self.year, self.month = year, month
    def __repr__(self):
        return f"Month(year={self.year}, month={self.month})"
    def <span class="fragment bold" data-fragment-index=1>__eq__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>==</span> (other.year, other.month)
    def <span class="fragment bold" data-fragment-index=1>__lt__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>&lt;</span> (other.year, other.month)
    def <span class="fragment bold" data-fragment-index=1>__gt__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>&gt;</span> (other.year, other.month)
    def <span class="fragment bold" data-fragment-index=1>__le__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>&lt;=</span> (other.year, other.month)
    def <span class="fragment bold" data-fragment-index=1>__ge__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>&gt;=</span> (other.year, other.month)</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - You might notice there's a lot of code duplication here
          - All five of those **(click)** comparison dunder methods are pretty much the same method
          - The only real difference is **(click)** the operator they use
          - There is a helper in the standard library to make this class a bit shorter
        </aside>
      </section>

      <section>
        <pre class=""><code data-trim data-noescape>
from functools import total_ordering


@total_ordering
class Month:
    def __init__(self, year, month):
        self.year, self.month = year, month
    def __repr__(self):
        return f"Month(year={self.year}, month={self.month})"
    def __eq__(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) == (other.year, other.month)
    def __lt__(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) &lt; (other.year, other.month)
        </code></pre>
        <aside class="notes" data-markdown>
          - It's called `total\_ordering` and it lives in the `functools` module
          - It allows us to implement just 2 comparison operators and it'll implement the others automatically
          - Here we're implementing equality with `\_\_eq\_\_` and less than with `\_\_lt\_\_`
          - But there's still a lot of boilerplate code needed for this class
          - We're going to take a look at an even better way to make this class later, but first we're going to take a look at another example
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>Case 2: Point class</h1>
        <aside class="notes" data-markdown>
          - Let's take a look at one more example
          - This time we're going to look at a class that represents a three-dimensional point
        </aside>
      </section>

      <section>
        <h2><span class="fragment" data-fragment-index=6>Iterability</span> <span class="fragment" data-fragment-index=8>and Immutability</span></h2>
        <div class="container">
        <pre class="col python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>p = Point(1, 2, 3)
>>> </span><span class="fragment" data-fragment-index=2>p
Point(x=1, y=2, z=3)
>>> </span><span class="fragment" data-fragment-index=3>p == Point(1, 2, 3)
True
>>> </span><span class="fragment" data-fragment-index=4>x, y, z = p
>>> </span><span class="fragment" data-fragment-index=5>x
1
>>> </span><span class="fragment" data-fragment-index=9>p.x = 4
Traceback (most recent call last):
  File "&lt;stdin>", line 1
  File "&lt;string>", line 3
AttributeError: object is immutable
>>> </span><span class="fragment" data-fragment-index=13>{Point(1, 2, 3), Point(1, 2, 3)}
{Point(x=1, y=2, z=3)}</span>
        </code></pre>
        <pre class="col python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index=1>class Point:
    def __init__(self, x, y, z):
        pass</span>
    <span class="fragment" data-fragment-index=2>def __repr__(self):
        pass</span>
    <span class="fragment" data-fragment-index=3>def __eq__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=7>def __iter__(self):
        pass</span>
    <span class="fragment" data-fragment-index=10>def __setattr__(self, name, value):
        pass</span>
    <span class="fragment" data-fragment-index=14>def __hash__(self):
        pass

        </span>
        </code></pre>
        </div>
        <aside class="notes" data-markdown>
          - Just as in our last example, we're going to want our class to **(click)** accept arguments, **(click)** have a nice string representation, and **(click)** allow itself to be compared to other `Point` objects
          - But what if we also want to allow our class **(click)** to be unpacked into three coordinate variables using multiple assignment?
          - Meaning we can take our point and **(click)** unpack it into `x`, `y`, and `z` values
          - Multiple assignment requires that our class **(click)** be iterable
          - We'll need a **(click)** dunder iter method for that
          - *(pause)*
          - We might also want our class to be **(click)** immutable, meaning **(click)** we can't override any of the attributes after we've created a `Point` object
          - For this we need to make a **(click)** custom dunder setattr method, which is a bit of an advanced thing to do but it works
          - And if our class is immutable it should be **(click)** safe to use it in dictionary keys and sets
          - But we'll need **(click)** a dunder hash method for that
          - So after all of this work, our `Point` class ends up looking something like this...
        </aside>
      </section>

      <section>
        <pre class=""><code data-trim data-noescape>
class Point:
    def __init__(self, x, y, z):
        self.x, self.y, self.z = x, y, z
    def __repr__(self):
        return f"Point(x={self.x}, y={self.y}, z={self.z})"
    def __eq__(self, other):
        if not isinstance(other, Point):
            return NotImplemented
        return tuple(self) == tuple(other)
    def __iter__(self):
        yield from (self.x, self.y, self.z)
    def __setattr__(self, attribute, value):
        raise AttributeError("object is immutable")
    __delattr__ = __setattr__
    def __hash__(self):
        return hash(tuple(self))
        </code></pre>
        <aside class="notes" data-markdown>
          - This class does quite a bit without too many lines of code
          - Some of this is probably new to you
          - If you haven't seen `yield` before, you can google generators and iterators and how to make them on your own
          - This is basically **code copy-paste time** here.  Instead of memorizing all this, we can always copy-paste this class format when we need it.
          - So while a lot of these things might be *new* to you, this code is pretty succinct for how much it does. But this is pretty much all boilerplate code.  We shouldn't have to type this out, or copy-paste it whenever we need code that works this way.
          - Fortunately, there is a tool in the Python standard library that can use to help us
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>namedtuple</h1>
        <aside class="notes" data-markdown>
          - It's a helper function called `namedtuple` and it's in both Python 2 and Python 3
        </aside>
      </section>

      <section>
        <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
from collections import namedtuple

<span class="fragment" data-fragment-index=2>Point = <span class="fragment bold" data-fragment-index=10>namedtuple('Point', ['x', 'y', 'z'])</span></span>
        </code></pre>
        <pre class="python fragment" data-fragment-index=3><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment" data-fragment-index=4>p
Point(x=1, y=2, z=3)
>>> </span><span class="fragment" data-fragment-index=5>p == Point(1, 2, 3)
True
>>> </span><span class="fragment" data-fragment-index=6>p.x = 4
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AttributeError: cannot set attribute
>>> </span><span class="fragment" data-fragment-index=7>{Point(1, 2, 3), Point(1, 2, 3)}
{Point(x=1, y=2, z=3)}</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - The **(click)** `namedtuple` function lives in the `collections` module
          - `namedtuple` isn't a class so much as a factory function that creates new classes
          - When you call `namedtuple`, you pass **(click)** in the name of the class and the attributes the class should have, and it'll dynamically create a new class for you
          - The **(click)** classes created by `namedtuple` have **(click)** a friendly string representation
          - **(click)** They can be compared to each other
          - And **(click)** they're immutable, and **(click)** hashable, just like tuples
          - So out-of-the-box, `namedtuple` pretty much gives us all the things we were looking for in our `Point` class
          - The **(click)** way we call `namedtuple` might seem a little unintuitive though
          - As of Python 3.5, there's an even better way to use `namedtuple`
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
from typing import NamedTuple

<span class="fragment" data-fragment-index=1><span class="fragment bold-current" data-fragment-index=4>class Point(NamedTuple)</span>:
    <span class="fragment bold-current" data-fragment-index=5>x: float <span class="fragment current-visible" data-fragment-index=6>= 0</span>
    y: float <span class="fragment current-visible" data-fragment-index=6>= 0</span>
    z: float <span class="fragment current-visible" data-fragment-index=6>= 0</span><span class="fragment" data-fragment-index=7></span></span></span>
        </code></pre>
        <pre class="python fragment" data-fragment-index=2><code data-trim data-noescape>
from collections import namedtuple

Point = <span class="fragment bold-current" data-fragment-index=3>namedtuple('Point', ['x', 'y', 'z'])</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - Instead of using `collections.namedtuple`, you can now **(click)** inherit from the `typing.NamedTuple` class which does the same thing
          - So while **(click)** `collections.namedtuple` is... a **(click)** function that creates a class for you, **(click)** `typing.NamedTuple` is actually a class that you can inherit from
          - This `NamedTuple` class gives you pretty much the same thing as the `namedtuple` function except that we use **(click)** type hints to define its attributes
          - And you can specify **(click)** default values for your attributes, which can be pretty handy in some cases
          - Though it probably doesn't make much sense in the particular example we have here **(click)**
          - *(pause)*
          - In general named tuples are a pretty great way to get something a bit more descriptive than the built-in tuple type
          - But if you're using named tuples to replace a class that doesn't need to work like a tuple, you might want to think twice.  Let me explain why.
        </aside>
      </section>

      <section>
        <h2>named<span class="fragment bold">tuple</span> are tuples</h2>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">Point(1, 2, 3) &lt; Point(4, 5, 6)
True
>>> </span><span class="fragment">Point(1, 2, 3) + Point(4, 5, 6)</span><span class="fragment">
(1, 2, 3, 4, 5, 6)
>>> </span><span class="fragment">Point(1, 2, 3) * 2</span><span class="fragment">
(1, 2, 3, 1, 2, 3)
>>> </span><span class="fragment">len(Point(1, 2, 3))
3</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - Named tuples inherit from **(click)** tuples
          - Which means they inherit all the features that tuples have
          - So they can be **(click)** ordered... which can be useful but sometimes it doesn't make sense, like in this case for example
          - They can also be **(click)** added to each other... but the object that comes back from this operation **(click)** might not be what you'd expect
          - The same is true for multiplication **(click)**
          - You can multiply namedtuples by integers, but the **(click)** thing you get back is a little odd
          - Also they have **(click)** a length... which also doesn't necessarily make sense in all cases
          - So named tuples can be useful, but you sometimes have to be careful while using them
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
from typing import NamedTuple

class Point(NamedTuple):
    x: float
    y: float
    z: float
    def __lt__(self, other): raise TypeError
    def __le__(self, other): raise TypeError
    def __gt__(self, other): raise TypeError
    def __ge__(self, other): raise TypeError
    def __add__(self, other): raise TypeError
    def __mul__(self, other): raise TypeError
    def __rmul__(self, other): raise TypeError
    def __len__(self, other): raise TypeError
        </code></pre>
        <aside class="notes" data-markdown>
          - You can fix these problems by overloading the appropriate operators in your named tuple class so that they all raise exceptions
          - But finding and removing features that you don't want is often trickier than adding features that you do want
          - If these features of named tuples are inappropriate for your use case, you probably shouldn't use them
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>attrs</h1>
        <aside class="notes" data-markdown>
          - One alternative to named tuples is `attrs`
          - `attrs` is a third-party library that makes it easier to create classes with certain common features
        </aside>
      </section>

      <section>
        <pre class="bash fragment"><code data-trim data-noescape>
$ pip install attrs
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
<span class="fragment bold-current">import attr</span>

<span class="fragment bold-current">@attr.s(auto_attribs=True)</span>
class Point:
    <span class="fragment bold-current">x: float</span>
    y: float
    z: float
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment">p
Point(x=1, y=2, z=3)
>>> </span><span class="fragment">p == Point(1, 2, 3)
True
>>> </span><span class="fragment">p &lt; Point(4, 5, 6)
True</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - You can get attrs by **(click)** pip-installing it
          - **(click)** After that you can use it by **(click)** importing attr (without the s, which is a little odd)
          - And then **(click)** decorating your class with the `attr.s` decorator
          - That `auto_attribs` argument allows us to use **(click)** type hints to define our attributes
          - By default, **(click)** `attrs` classes get **(click)** a nice string representation
          - And **(click)** they can be logically compared to other objects of the same type
          - But **(click)** they can also be *ordered* the same way named tuples can, which again is a bit odd in this case
          - Our `Point` objects can be ordered and they aren't iterable or immutable yet
          - If we want our `Point` class to work just like the one we made *manually* before, we could do this
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
import attr

@attr.s(auto_attribs=True, <span class="fragment bold-current" data-fragment-index=3>cmp=False</span>, <span class="fragment bold-current" data-fragment-index=1>frozen=True</span>)
class Point:
    x: float
    y: float
    z: float
    <span class="fragment bold-current" data-fragment-index=2>def __iter__(self):
        yield from (self.x, self.y, self.z)</span>
    <span class="fragment bold-current" data-fragment-index=4>def __eq__(self, other):
        if not isinstance(other, Point):
            return NotImplemented
        return tuple(self) == tuple(other)</span>
    <span class="fragment bold-current" data-fragment-index=5>def __hash__(self):
        return hash(tuple(self))</span><span class="fragment" data-fragment-index=10></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - Here we've **(click)** frozen our object so the attributes can't be modified
          - We've also added **(click)** a dunder iter method to make our object work with multiple assignment
          - And we've **(click)** disabled comparisons so we don't get automatic ordering, but that means we need to implement **(click)** a dunder eq method
          - We also need to implement **(click)** a dunder hash method ourselves
          - Normally we would get that for free with frozen classes, but disabling comparisons also disables hashing by default **(click)**
          - So the attrs library is more powerful than named tuples, but it does sometimes take a bit of playing to get it just right
          - Also it's a third party library which means you'll need to install it whenever you want to use it
          - There's something similar to `attrs` that's actually bundled with Python though
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>dataclasses</h1>
        <aside class="notes" data-markdown>
          - Data classes is essentially a simplified version of the `attrs` library that's built-in to the Python standard library
        </aside>
      </section>

      <section data-transition="none-out" data-transition-speed="default-in fast-out">
        <pre class="python"><code data-trim data-noescape>
<span class="fragment bold-current">from dataclasses import dataclass</span>

<span class="fragment bold-current">@dataclass</span>
class Point:
    <span class="fragment bold-current">x: float</span>
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> <span class="fragment">p = Point(1, 2, 3)
>>> </span><span class="fragment">p
Point(x=1, y=2, z=3)
>>> </span><span class="fragment">p == Point(1, 2, 3)
True
>>> </span><span class="fragment">p &lt; Point(4, 5, 6)
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: '&lt;' not supported between instances of 'Point' and 'Point'</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - To use dataclasses, you'll **(click)** import `dataclass` from the `dataclasses` library
          - And you'll **(click)** decorate your class, the same way you can with `attrs`
          - The syntax relies on **(click)** type hinting, just like `typing.NamedTuple` and `attrs` do
          - This **(click)** `Point` class has **(click)** a nice string representation and **(click)** it supports comparisons
          - But **(click)** it doesn't support ordering... and that's perfect because we don't want our class to orderable
          - But this `Point` class doesn't work quite the way we want it to yet
        </aside>
      </section>

      <section data-transition="none-in none-out" data-transition-speed="fast-in default-out">
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> p = Point(1, 2, 3)
>>> <span class="fragment">x, y, z = p
</span><span class="fragment">Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: cannot unpack non-iterable Point object
>>> </span><span class="fragment">p.x = 4</span><span class="fragment">
>>> p
Point(x=4, y=2, z=3)

</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - If we try to use this point with multiple assignment **(click)**, we'll get an error **(click)**, because our `Point` class is not iterable so we can't unpack into 3 variables
          - Also if we **(click)** try to assign to the `x` attribute in our class
          - It **(click)** works... which isn't good because our class is *supposed to be* **immutable**, meaning we shouldn't be able to change the attributes in our `Point` objects
          - We're expecting to get an error here instead
          - So we need to make our `Point` class iterable and immutable
        </aside>
      </section>

      <section data-transition="none-out" data-transition-speed="default-in fast-out">
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
    z: float
    <span class="fragment">def __iter__(self):
        yield from <span class="fragment bold-current">(self.x, self.y, self.z)</span></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - To make our class iterable, we can add **(click)** a dunder iter method
          - Which you could copy-paste from the Point class that we made manually earlier, before we looked at namedtuples and attrs and dataclasses
          - But instead of hard-coding **(click)** self.x, self.y, and self.z, you could instead copy-paste this code
          - *(pause)*
        </aside>
      </section>

      <section data-transition="none-in none-out" data-transition-speed="fast-in fast-out">
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, astuple

@dataclass<span class="fragment" data-fragment-index=4><strong>(frozen=True)</strong></span>
class Point:
    x: float
    y: float
    z: float
    def __iter__(self):
        yield from astuple(self)
        </code></pre>
        <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment" data-fragment-index=2>x, y, z = p
>>> </span><span class="fragment" data-fragment-index=3>x
1
>>> y
2</span></code></pre>

        <aside class="notes" data-markdown>
          - The `dataclasses` library has an `astuple` helper that allows us to get a tuple that contains our object's attributes without manually specifying each of the attributes.  Which is kind of nifty.
          - *(pause)*
          - So our **(click)** `Point` class is iterable now, meaning we can use **(click)** multiple assignment with it
          - Which is great **(click)**
          - But it's not immutable yet
          - To make it immutable, we can set the **(click)** `frozen` attribute when using our `dataclass` decorator
        </aside>
      </section>

      <section data-transition="none-out" data-transition-speed="fast-in default-out">
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, astuple

@dataclass(frozen=True)
class Point:
    x: float
    y: float
    z: float
    def __iter__(self):
        yield from astuple(self)
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment" data-fragment-index=5>p.x = 4</span><span class="fragment">
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 3, in __setattr__
dataclasses.FrozenInstanceError: cannot assign to field 'x'</span>
        </code></pre>

        <aside class="notes" data-markdown>
          - Now that we've frozen our `Point` class, if we **(click)** try to assign an attribute on a point object, **(click)**, we'll get an error
          - Which is just what we're looking for
          - So our class is now iterable, immutable, comparable, and it has a nice representation.  But it's *not* orderable, it *doesn't have a length, and it *doesn't* have other features that don't make sense either
          - So using dataclasses, we've made a **friendly class** that has just the features that we want
          - All in less than 10 lines of code.  I think this is pretty cool.
        </aside>
      </section>


      <section>
        <h2>dataclasses</h2>
        <ul>
          <li class="fragment">Built-in to standard library <span class="fragment">(in Python 3.7)</span></li>
          <li class="fragment">Available as a third-party library</li>
          <li class="fragment">dataclasses is simpler, but less feature-rich than attrs</li>
          <li class="fragment">While attrs supports both Python 2 and Python 3, dataclasses only work on Python 3</li>
        </ul>
        <aside class="notes" data-markdown>
          - When I told you before that dataclasses are **(click)** included in the Python standard library, I meant that **(click)** it's included with Python 3.7
          - Which was just released pretty recently, so you're probably not using it yet
          - It's also **(click)** available as a third-party library though, so you can pip-install it from any version of Python 3.  If you're on Python 2, you're out of luck.
          - If you need Python 2 support **(click)** or if you need **(click)** more features than dataclasses provide, you might want to reach for the `attrs` library instead
          - The dataclasses library was partially inspired attrs, so many of the design decisions made by each are similar
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>Friendly Class Recipes</h1>
        <aside class="notes" data-markdown>
          - Let's take a look at some common uses for data classes
          - I'm intending this section to act as sort of a recipe book for how to make different types of friendly classes
          - I don't mean it to be an infomercial for data classes
          - But it might be an infomercial for data classes
        </aside>
      </section>

      <section data-transition="none-out" data-transition-speed="default-in fast-out">
        <h2>What you get out of the box</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> p
Point(x=1, y=2, z=3)
<span>>>> p == Point(1, 2, 3)
True

</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - Without any other customization, data classes give you:
            - a good string representation for your object
            - and they allow you to compare objects to each other with the equality and inequality operators
          - That's what you get out of the box with data classes, without any extra customization
          - As I just showed you, it's also possible to make your dataclasses immutable...
        </aside>
      </section>

      <section data-transition="none-in none-out" data-transition-speed="fast-in fast-out">
        <h2>Immutability!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass<span class="fragment bold-current">(frozen=True)</span>
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment">p.x = 4
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 3, in __setattr__
dataclasses.FrozenInstanceError: cannot assign to field 'x'</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - By setting **(click)** `frozen` to True
          - This makes it so we **(click)** can't assign to any of the attributes in our class after it's been constructed
          - And as an added bonus, setting frozen to True also makes your class hashable...
        </aside>
      </section>

      <section data-transition="none-in none-out" data-transition-speed="fast-in fast-out">
        <h2>Hashability!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass(frozen=True)
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">aliveness= {Point(1, 2, 3): True, Point(4, 5, 6): False}
>>> </span><span class="fragment">aliveness[Point(4, 5, 6)]
False
>>> aliveness[Point(1, 2, 3)]
True

</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - Meaning we can use our objects in sets or as **(click)** keys in dictionaries
          - Which can be pretty handy **(click)**
          - Normally dataclasses aren't hashable because it's usually a bad idea to allow mutable objects to be hashable.  There is a way to make non-frozen classes hashable, but I'm going to skip over that.
        </aside>
      </section>

      <section data-transition="none-in slide-out" data-transition-speed="fast-in default-out">
        <h2>Iterability!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass<span class="fragment" data-fragment-index=3>, astuple</span>

@dataclass
class Point:
    x: float
    y: float
    z: float
    <span class="fragment" data-fragment-index=3>def __iter__(self):
        yield from astuple(self)</span>
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
<span class="fragment" data-fragment-index=1>>>> x, y, z = p</span>
<span class="fragment" data-fragment-index=2>>>> tuple(p)
(1, 2, 3)
</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - And we've already seen that if we want to make a dataclass that is iterable, meaning it **(click)** supports multiple assignment or **(click)** can be iterated over...
          - That we can make **(click)** a dunder iter method for that
          - *(pause)*
          - One thing I haven't shown you is how to make orederable data classes...
        </aside>
      </section>

      <section data-transition="slide-in none-out" data-transition-speed="default-in fast-out">
        <h2>Orderability?</h2>
        <pre class=""><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Month:
    year: int
    month: int
        </code></pre>
        <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> eol_month = Month(2020, 1)
>>> eol_month
Month(year=2020, month=1)
>>> <span class="fragment">eol_month > Month(2019, 12)</span>
<span class="fragment">Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: '>' not supported between instances of 'Month' and 'Month'</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - Before we talked about named tuples, attrs, *or* data classes, we made a `Month` class
          - We made our `Month` class orderable, meaning **(click)** we were able to use the less than and greater than operators to compare different months
          - Data classes **(click)** don't support ordering by default
          - But if we *do* want orderable data classes...
        </aside>
      </section>

      <section data-transition="none-in slide-out" data-transition-speed="fast-in default-out">
        <h2>Orderability!</h2>
        <pre class=""><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass<span class="fragment bold-current">(order=True)</span>
class Month:
    year: int
    month: int
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> Month(2020, 1) > Month(2019, 12)
True
>>> months = [Month(2018, 6), Month(2018, 1), Month(2019, 10)]
>>> <span class="fragment">print(*sorted(months), sep='\n')
Month(year=2018, month=1)
Month(year=2018, month=6)
Month(year=2019, month=10)</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - We can set **(click)** `order` equal to `True` when we decorator our `dataclass`
          - This makes our class order items lexicographically **(click)**, which is just the fancy name for the way that Python orders tuples, lists, strings, and pretty much every other type of orderable collection
          - So ordering is disabled by default, but if you want ordering you can turn it on
        </aside>
      </section>

      <section data-transition="slide-in none-out" data-transition-speed="default-in fast-out">
        <h2>Summability and other operations?</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, astuple

@dataclass
class Vector:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Vector(1, 2, 3)
>>> q = Vector(4, 5, 6)
>>> <span class="fragment">p + q
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: unsupported operand type(s) for +: 'Vector' and 'Vector'
>>> <span><span class="fragment">q - p
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: unsupported operand type(s) for +: 'Vector' and 'Vector'</span></code></pre>
        <aside class="notes" data-markdown>
          - What if you want other operations on your objects?
          - For example what if have a `Vector` class and we want to be able to **(click)** add together or **(click)** subtract different vectors from each other?
          - Data classes don't support that by default, so you have to implement those operations yourself
        </aside>
      </section>

      <section data-transition="none-in slide-out" data-transition-speed="fast-in default-out">
        <h2>Summability and other operations!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, astuple

@dataclass
class Vector:
    x: float
    y: float
    z: float
    def __iter__(self):
        yield from astuple(self)
    def __add__(self, other):
        return Vector(*(a + b for a, b in zip(self, other)))
    def __sub__(self, other):
        return Vector(*(a - b for a, b in zip(self, other)))        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">Vector(1, 2, 3) + Vector(4, 5, 6)
Vector(x=5, y=7, z=9)
>>> </span><span class="fragment">Vector(4, 5, 6) - Vector(1, 2, 3)
Vector(x=3, y=3, z=3)</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - But it's not hard
          - Here we've implemented dunder add and dunder sub methods for **(click)** addition and **(click)** subtraction
          - Here we're looping over our vector instances and adding each field together individually
          - And that works because we've made our class is iterable, since it has that dunder iter method
          - Because our class is iterable, we're able to delegate work to our dunder iter method, which makes our dunder add and dunder sub implementations a little more flexible
        </aside>
      </section>

      </section>

      <section>

      <section data-transition="slide-in slide-out" data-transition-speed="slide-in default-out">
        <h2>Advanced Recipes</h2>
        <aside class="notes" data-markdown>
          - So I have even more recipes, but they're kind of advanced and I'm going to skip over these slides entirely because I don't have time to go through them
          - I will tweet out a link to the slides later in case you're interested in them though
          - **[skip this section]**
          - Before we wrap up, I'd like you to consider...
        </aside>
      </section>

      <section>
        <h2>Metadata on fields!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, field, fields

@dataclass
class Point:
    <span class="fragment bold-current">x: float = field(metadata={'iter': True})
    y: float = field(metadata={'iter': True})
    z: float = field(metadata={'iter': True})</span>
    <span class="fragment bold-current">color: str</span><span class="fragment"></span>
    def __iter__(self):
        return (
            getattr(self, field.name)
            for field in fields(self)
            if field.metadata.get('iter')
        )
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> x, y, z = Point(1, 2, 3, color='red')
>>> (x, y, z)
(1, 2, 3)
        </code></pre>
        <aside class="notes" data-markdown>
          - The dataclasses library has a `field` class that can be used to store metadata about each of our fields
          - metadata allows you to attach information to your class fields and kind of extend the functionality of dataclasses
          - Here we're making **(click)** some of our attributes iterable and **(click)** some of them not
          - **(click)** These `field` objects can be used for lots of other things
          - One example is compare, which can be used to make some fields non-comparable, which could be handy in some cases
        </aside>
      </section>

      <section>
        <h2>Non-comparable fields!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, field, fields

@dataclass
class Point:
    x: float = field(metadata={'iter': True})
    y: float = field(metadata={'iter': True})
    z: float = field(metadata={'iter': True})
    color: str = field(<span class="fragment bold-current">compare=False</span>)
    def __iter__(self):
        return (
            getattr(self, field.name)
            for field in fields(self)
            if field.metadata.get('iter')
        )
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
>>> p1 = Point(1, 2, 3, color='red')
>>> p2 = Point(1, 2, 3, color='blue')
>>> <span class="fragment">p1 == p2
</span><span class="fragment">True</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - Adding `compare=False` to a dataclass **(click)** removes that field from comparisons
          - So if we have **(click)** two points that have the same coordinates but one is red and one is blue
          - And we ask whether these two points are equal **(click)**
          - We'll see that **(click)** they are because we're ignoring the color when we compare them
        </aside>
      </section>

      <section>
        <h2>Dynamic default values!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, field, fields
import random

def random_color(): return random.choice(['purple', 'blue', 'red'])

@dataclass
class Point:
    x: float = field(metadata={'iter': True})
    y: float = field(metadata={'iter': True})
    z: float = field(metadata={'iter': True})
    color: str = field(<span class="fragment bold-current">default_factory=random_color</span>, compare=False)
    def __iter__(self):
        ...
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">p1 = Point(1, 2, 3)
>>> </span><span class="fragment">p1.color
'blue'
        </code></pre>
        <aside class="notes" data-markdown>
          - `default_factory` is another advanced feature of data class fields
          - With `default_factory` we can specify a function that chooses a random color
          - So that when we **(click)** create a point without a color specified **(click)**, it'll call that `random_color` function to randomly choose a color for us
          - Alright just one more advanced feature of data classes...
        </aside>
      </section>

      <section>
        <h2>Auto-created fields</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, field, fields
import random

def random_color(): return random.choice(['purple', 'blue', 'red'])

@dataclass
class Point:
    x: float = field(metadata={'iter': True})
    y: float = field(metadata={'iter': True})
    z: float = field(metadata={'iter': True})
    color: str = field(compare=False, <span class="fragment bold-current" data-fragment-index=5>init=False</span>)
    <span class="fragment bold-current" data-fragment-index=6>def __post_init__(self):
        self.color = random_color()</span>
    def __iter__(self):
        ...
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> </span><span class="fragment" data-fragment-index=1>point = Point(1, 2, 3)
>>> </span><span class="fragment" data-fragment-index=2>point.color
'purple'
>>> </span><span class="fragment" data-fragment-index=3>point = Point(1, 2, 3, color='blue')
TypeError: __init__() got an unexpected keyword argument 'color'</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - Auto-created fields
          - We've already made a data class that sets a **(click)** a dynamic default value for **(click)** our `color` attribute
          - This class here also goes a step further by disallowing that color attribute from being specified manually **(click)** give us an error if we try to specify that attribute manually
          - This works by setting **(click)** `init=False` on our dataclass `field` and creating a custom **(click)** dunder post_init method, which is a dataclass-specific dunder method that gets called by dunder init
          - **(click)** These are all pretty complex things I just flashed by and if you actually need any of those features, you can consult the dataclasses documentation on your own
          - Before we wrap up, I'd like you to consider...
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>Should I make a class?</h1>
        <h4 class="fragment">(Examples inspired by <a href="http://exercism.io/">exercism.io</a>)</h4>
        <aside class="notes" data-markdown>
          - Whether you even need classes.
          - I'd like to take a look at 2 code snippets that I wrote to solve exercises on **(click)** Exercism.io, which is a popular programming exercise website
          - Exercism is wonderful, except in a few cases where it pushes to write code that is... *un-friendly*
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
class Matrix:
    """Turn a string into a matrix-like thing."""
    def __init__(self, string):
        self.string = string
    @property
    def rows(self):
        return [
            [float(x) for x in row.split()]
            for row in self.string.splitlines()
        ]
    @property
    def columns(self):
        return [
            list(column)
            for column in zip(*self.rows)
        ]
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
>>> <span class="fragment">matrix = Matrix("9 8 7\n5 3 2\n6 6 7")
>>> </span><span class="fragment">matrix.rows
[[9, 8, 7], [5, 3, 2], [6, 6, 7]]
>>> </span><span class="fragment">matrix.columns
[[9, 5, 6], [8, 3, 6], [7, 2, 7]]</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - This is a class that represents a matrix **(click)**
          - This class accepts **(click)** a string that represents a matrix of numbers, separated by spaces and newline characters
          - When we construct a `Matrix` from our class, that `matrix` object will have **(click)** a rows attribute that gives us back the rows in our matrix
          - And it also has **(click)** a columns attribute that gives us back a *transposed* version of those rows
          - *This class* **does not** need to exist
          - I say that, because we could *replace* this class...
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
<span class="fragment">def matrix_from_string(string):
    """Convert rows of numbers to list of lists."""
    return [
        [float(x) for x in row.split()]
        for row in string.splitlines()
    ]</span>

<span class="fragment">def transpose(matrix):
    """Return a transposed version of given list of lists."""
    return [
        list(column)
        for column in zip(*matrix)
    ]</span>
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
>>> matrix = matrix_from_string("9 8 7\n5 3 2\n6 6 7")
>>> <span class="fragment">matrix
[[9, 8, 7], [5, 3, 2], [6, 6, 7]]
>>> </span><span class="fragment">transpose(matrix)
[[9, 5, 6], [8, 3, 6], [7, 2, 7]]</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - With two functions:
          - matrix_from_string **(click)** and transpose **(click)**
          - We call call that `matrix_from_string` function the **(click)** same way we called our `Matrix` class constructor before
          - But instead of giving us a `matrix` object back, **(click)** it gives us back a list of numbers, just like our `rows` attribute did on our `matrix` object
          - If we pass that list of numbers to the `transpose` function **(click)**, we'll get back the transpose matrix of that list of numbers, just like we did when we used the `columns` attribute on the matrix that we had before
          - We just replaced a class with two functions
          - You might think: so what?  We had a three method class and now we just have 2 functions.  That wasn't really a big deal.
          - Let's look at another example
        </aside>
      </section>


      <section>
        <pre class="python"><code data-trim data-noescape>
class SpaceAge:
    SECONDS_IN_EARTH_YEAR = 31557600.0
    def __init__(self, seconds):
        self.seconds = seconds
    def on_earth(self):
        annual_seconds = self.SECONDS_IN_EARTH_YEAR
        return round(self.seconds / annual_seconds, 2)
    def on_mercury(self):
        annual_seconds = self.SECONDS_IN_EARTH_YEAR * 0.2408467
        return round(self.seconds / annual_seconds, 2)
    def on_venus(self):
        annual_seconds = self.SECONDS_IN_EARTH_YEAR * 0.61519726
        return round(self.seconds / annual_seconds, 2)
    def on_mars(self):
        annual_seconds = self.SECONDS_IN_EARTH_YEAR * 1.8808158
        return round(self.seconds / annual_seconds, 2)
    # ...
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
>>> age = SpaceAge(seconds=1_000_000_000)
<span class="fragment">>>> age.on_earth()
31.69
>>> </span><span class="fragment">age.on_mars()
16.85
>>> </span><span class="fragment">age.on_mercury()
131.57</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - This is a class that allows you to calculate your age on a given planet given the number of seconds that you've been alive for
          - We can use this class by creating **(click)** a `SpaceAge` object with the number of seconds we've been alive
          - We can then calculate our age on various planets by calling the method that correspons to them
          - For example we can calculate our age on **(click)** `earth`, **(click)** `mars`, or **(click)** `mercury`
          - This is another class that doesn't need to exist
          - We could replace this whole class with one function
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
SECONDS_IN_EARTH_YEAR = 31557600

ORBITAL_PERIOD = {
    'earth': 1,
    'mercury': 0.2408467,
    'venus': 0.61519726,
    'mars': 1.8808158,
    'jupiter': 11.862615,
    'saturn': 29.447498,
    'uranus': 84.016846,
    'neptune': 164.79132,
}

def age_on_planet(<span class="fragment bold-current">seconds_alive</span>, <span class="fragment bold-current">planet</span>):
    """Return age on a given planet."""
    annual_seconds = SECONDS_IN_EARTH_YEAR * ORBITAL_PERIOD[planet]
    return round(seconds_alive / annual_seconds, 2)
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">age_on_planet(seconds=1_000_000_000, planet='earth')
31.69
>>> </span><span class="fragment">age_on_planet(seconds=1_000_000_000, planet='mars')
16.85
>>> </span><span class="fragment">age_on_planet(seconds=1_000_000_000, planet='mercury')
131.57</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - This `age_on_planet` function accepts **(click)** the number of seconds we've been alive and **(click)** the name of a planet and it returns our age on that planet
          - Just as before, we can get our age on **(click)** `earth`, **(click)** `mars`, or **(click)** `mercury`
          - But we don't have to construct a new class instance to do it
          - *(pause)*
          - You **do not** always need classes
          - Friendly classes are great, but the friendliest code sometimes doesn't have classes at all
        </aside>
      </section>

      </section>

      <section>
        <h2>When making classes, consider...</h2>
        <ul>
          <li class="fragment">You don't always need custom classes for your data <nobr class="fragment">(see Jack Diederich's <a href="https://www.youtube.com/watch?v=o9pEzgHorH0">Stop Writing Classes</a>)</nobr></li>
          <li class="fragment">Custom can make things very handy, but they can be a step backward unless you <strong>make them friendly</strong></li>
          <li class="fragment">Friendly classes can require a lot of boilerplate code</li>
          <li class="fragment">To avoid distracting boilerplate code, use <code>dataclasses</code> <span class="fragment">or <code>attrs</code> for creating custom data-heavy classes</span></li>
        </ul>
        <aside class="notes" data-markdown>
          - So when making classes I'd like to you to consider **(click)** whether you even need a class.  Because you often don't.
          - **(click)** There's a talk on this subject I'd recommend watching called Stop Writing Classes
          - If you do decide you need a class, you should make it a friendly one.  **(click)** Using your class should feel *almost* as natural as using one of Python's built-in data types
          - **(click)** Creating a friendly class involves writing a lot of boilerplate code
          - **(click)** But the dataclasses library can help with this
          - If you're on Python 3.7, it comes bundled with Python. If you're on an earlier version of Python 3, you can pip-install it.
          - And there's always the attrs library **(click)**, for times when dataclasses isn't enough for you or if you're still using Python 2
        </aside>
      </section>

      <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
        <h2>Need help getting your team <nobr>up to speed on Python?</nobr></h2>
        <h3>
          <strong>Trey Hunner</strong><br>
          <small>Python &amp; Django Team Trainer</small>
        </h3>
        <p>
          <small>
            Contact me: <a href="mailto:&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;">&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;</a>
          </small>
        </p>
        <p>
        <a href="http://truthful.technology"><img src="logo.svg" class="no-style logo"></a>
        <a href="http://pythonmorsels.com"><img src="python-morsels-logo.svg" class="no-style logo"></a>
        </p>
        <aside class="notes" data-markdown>
          - I'd love to help you improve your Python skills
          - Find me in the halls or at my booth if you'd like to chat about that later
          - Thank you!
        </aside>
      </section>


      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/truthful.js"></script>


    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>

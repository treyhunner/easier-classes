<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Easier Classes: Python Classes Without All The Cruft</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Easier Classes</h1>
          <h2>Python Classes Without All The Cruft</h2>
          <p>
          <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            Alright.  Before we jump into this talk, let me quickly introduce myself.
          </aside>
        </section>

        <section>
          <div class="aboutme-card">
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos" alt="Truthful Technology"></a>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonmorsels.com"><img src="morsels-logo.svg" class="no-style aboutme-logos" alt="Python Morsels"></a>
          </div>
          <aside class="notes" data-markdown>
            - My name is Trey
            - I help Python &amp; Django teams on-board new teammates and turn their front-end developers into full-stack Django developers.
            - And I run a Python exercise subscription service where where I send out 1 Python exercise every week.  It's called Python Morsels.
            - Let's talk about classes.
          </aside>
        </section>

      </section>

      <section>
        <h3 class="fragment strike" data-fragment-index=1>Pythonic Classes</h3>
        <h2 class="fragment" data-fragment-index=1>Friendly Classes</h2>
        <ul>
          <li class="fragment">have nice string representations</li>
          <li class="fragment">can be compared to each other</li>
          <li class="fragment">embrace operator overloading</li>
        </ul>
        <aside class="notes" data-markdown>
          - I'd like to talk about making classes that are easy for developers to use
          - I'm tempted to use the phrase Pythonic classes to describe this idea, but that word Pythonic is a bit loaded, so I'm going to instead say that we're making **friendly** classes **(click)**
          - Friendly classes are friendly for the developers who use them
          - Friendly classes **(click)** have a nice string representation
          - They **(click)** can be compared to each other in ways that make sense
          - And whenever it makes, they **(click)** overload operators to allow themselves to be addable, iterable, hashable on so on
        </aside>
      </section>

      <section>

      <section>
        <h1>Case 1: Month class</h1>
        <aside class="notes" data-markdown>
          Let's take a look at an example of a friendly class.
        </aside>
      </section>

      <section>
        <h2><span class="fragment" data-fragment-index=5>Comparability</span> <span class="fragment" data-fragment-index=9>and Orderability</span></h2>
        <div class="container">
        <pre class="col python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>m = Month(2018, 6)
>>> </span><span class="fragment" data-fragment-index=3>m
Month(year=2018, month=6)
>>> </span><span class="fragment" data-fragment-index=6>m == Month(2018, 6)
True
>>> </span><span class="fragment" data-fragment-index=7>m != Month(2018, 6)
False
>>> </span><span class="fragment" data-fragment-index=10>m &lt; Month(2018, 12)
True
>>> </span><span class="fragment" data-fragment-index=12>m > Month(2019, 1)
False
>>> </span><span class="fragment" data-fragment-index=14>m &lt;= Month(2018, 12)
True
>>> </span><span class="fragment" data-fragment-index=16>m >= Month(2018, 6)
True</span>
        </code></pre>
        <pre class="col python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index=2>class Month:
    def __init__(self, year, month):
        pass</span>
    <span class="fragment" data-fragment-index=4>def __repr__(self):
        pass</span>
    <span class="fragment" data-fragment-index=8>def __eq__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=11>def __lt__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=13>def __gt__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=15>def __le__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=17>def __ge__(self, other):
        pass</span>
        </code></pre>
        </div>
        <aside class="notes" data-markdown>
          - If you want a class in Python that **(click)** accepts attributes, you'll probably want **(click)** an initializer
          - If you want it to have **(click)** a helpful string representation, you'll also want **(click)** a dunder repr method
          - But what if you also wanted your classes to be **(click)** comparable to other classes?... using **(click)** equality and **(click)** inequality?
          - In that case you'll want **(click)** a dunder eq method.
          - If you wanted to go further, by allowing your classes to be **(click)** sortable, you'll need to implement **(click)** the less than operator with **(click)** dunder lt, **(click)** the greater than operator with **(click)** dunder gt, the **(click)** less than or equal to operator with **(click)** dunder le, and **(click)** the greater than or equal to operator with **(click)** dunder ge
          - After all this, our class is going to look pretty big
        </aside>
      </section>

      <section>
        <pre class=""><code data-trim data-noescape>
class Month:
    def __init__(self, year, month):
        self.year, self.month = year, month
    def __repr__(self):
        return f"Month(year={self.year}, month={self.month})"
    def <span class="fragment bold" data-fragment-index=1>__eq__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>==</span> (other.year, other.month)
    def <span class="fragment bold" data-fragment-index=1>__lt__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>&lt;</span> (other.year, other.month)
    def <span class="fragment bold" data-fragment-index=1>__gt__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>&gt;</span> (other.year, other.month)
    def <span class="fragment bold" data-fragment-index=1>__le__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>&lt;=</span> (other.year, other.month)
    def <span class="fragment bold" data-fragment-index=1>__ge__</span>(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) <span class="fragment highlight-blue" data-fragment-index=2>&gt;=</span> (other.year, other.month)</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - You might notice there's a lot of code duplication here
          - All five of those **(click)** comparison dunder methods are pretty much the same method
          - The only real difference is **(click)** the operator they use
          - There is a helper in the standard library to make this class a bit shorter
        </aside>
      </section>

      <section>
        <pre class=""><code data-trim data-noescape>
from functools import total_ordering


@total_ordering
class Month:
    def __init__(self, year, month):
        self.year, self.month = year, month
    def __repr__(self):
        return f"Month(year={self.year}, month={self.month})"
    def __eq__(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) == (other.year, other.month)
    def __lt__(self, other):
        if not isinstance(other, Month):
            return NotImplemented
        return (self.year, self.month) &lt; (other.year, other.month)
        </code></pre>
        <aside class="notes" data-markdown>
          - It's called `total_ordering` and it lives in the `functools` module
          - It allows us to implement just 2 comparison operators and it'll implement the others automatically
          - Here we're implementing equality with `__eq__` and less than with `__lt_`
          - But there's still a lot of boilerplate code needed for this class
          - We're going to take a look at an even better way to make this class later, but first we're going to take a look at another example
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>Case 2: Point class</h1>
        <aside class="notes" data-markdown>
          - Let's take a look at one more example
          - This time we're going to look at a class that represents a three-dimensional point
        </aside>
      </section>

      <section>
        <h2><span class="fragment" data-fragment-index=6>Iterability</span> <span class="fragment" data-fragment-index=8>and Immutability</span></h2>
        <div class="container">
        <pre class="col python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>p = Point(1, 2, 3)
>>> </span><span class="fragment" data-fragment-index=2>p
Point(x=1, y=2, z=3)
>>> </span><span class="fragment" data-fragment-index=3>p == Point(1, 2, 3)
True
>>> </span><span class="fragment" data-fragment-index=4>x, y, z = p
>>> </span><span class="fragment" data-fragment-index=5>x
1
>>> </span><span class="fragment" data-fragment-index=9>p.x = 4
Traceback (most recent call last):
  File "&lt;stdin>", line 1
  File "&lt;string>", line 3
AttributeError: object is immutable
>>> </span><span class="fragment" data-fragment-index=13>{Point(1, 2, 3), Point(1, 2, 3)}
{Point(x=1, y=2, z=3)}</span>
        </code></pre>
        <pre class="col python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index=1>class Point:
    def __init__(self, x, y, z):
        pass</span>
    <span class="fragment" data-fragment-index=2>def __repr__(self):
        pass</span>
    <span class="fragment" data-fragment-index=3>def __eq__(self, other):
        pass</span>
    <span class="fragment" data-fragment-index=7>def __iter__(self):
        pass</span>
    <span class="fragment" data-fragment-index=10>def __setattr__(self, name, value):
        pass</span>
    <span class="fragment" data-fragment-index=14>def __hash__(self):
        pass

        </span>
        </code></pre>
        </div>
        <aside class="notes" data-markdown>
          - Just as in our last example, we're going to want our class to **(click)** accept arguments, **(click)** have a nice string representation, and **(click)** allow itself to be compared to other `Point` objects
          - But what if we also want to allow our class **(click)** to be unpacked into three coordinate variables using multiple assignment?
          - Meaning we can take our point and **(click)** unpack it into `x`, `y`, and `z` values
          - Multiple assignment requires that our class **(click)** be iterable
          - We'll need a **(click)** dunder iter method for that
          - *(pause)*
          - We might also want our class to be **(click)** immutable, meaning **(click)** we can't override any of the attributes after we've created a `Point` object
          - For this we need to make a **(click)** custom dunder setattr method, which is a bit of an advanced thing to do but it works
          - And if our class is immutable it should be **(click)** safe to use it in dictionary keys and sets
          - But we'll need **(click)** a dunder hash method for that
          - So after all of this work, our `Point` class ends up looking something like this...
        </aside>
      </section>

      <section>
        <pre class=""><code data-trim data-noescape>
class Point:
    def __init__(self, x, y, z):
        self.x, self.y, self.z = x, y, z
    def __repr__(self):
        return f"Point(x={self.x}, y={self.y}, z={self.z})"
    def __eq__(self, other):
        if not isinstance(other, Point):
            return NotImplemented
        return tuple(self) == tuple(other)
    def __iter__(self):
        yield from (self.x, self.y, self.z)
    def __setattr__(self, attribute, value):
        raise AttributeError("object is immutable")
    __delattr__ = __setattr__
    def __hash__(self):
        return hash(tuple(self))
        </code></pre>
        <aside class="notes" data-markdown>
          - This class does quite a bit without too many lines of code
          - Some of this is probably new to you
          - If you haven't seen `yield` before, you can google generators and iterators and how to make them on your own
          - This is basically copy-paste code time here.  Instead of memorizing all this, we can always copy-paste this class format when we need it.
          - So while a lot of these things might be *new* to you, this code is pretty succinct for how much it does. But this is pretty much all boilerplate code.  We shouldn't have to type this out, or copy-paste it whenever we need code that works this way.
          - Fortunately, there is a tool in the Python standard library that can use to help us
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>namedtuple</h1>
        <aside class="notes" data-markdown>
          - It's a helper function called `namedtuple` and it's in both Python 2 and Python 3
        </aside>
      </section>

      <section>
        <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
from collections import namedtuple

<span class="fragment" data-fragment-index=2>Point = <span class="fragment bold" data-fragment-index=10>namedtuple('Point', ['x', 'y', 'z'])</span></span>
        </code></pre>
        <pre class="python fragment" data-fragment-index=3><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment" data-fragment-index=4>p
Point(x=1, y=2, z=3)
>>> </span><span class="fragment" data-fragment-index=5>p == Point(1, 2, 3)
True
>>> </span><span class="fragment" data-fragment-index=6>p.x = 4
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AttributeError: cannot set attribute
>>> </span><span class="fragment" data-fragment-index=7>{Point(1, 2, 3), Point(1, 2, 3)}
{Point(x=1, y=2, z=3)}</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - The **(click)** `namedtuple` function lives in the `collections` module
          - `namedtuple` isn't a class so much as a factory function that creates new classes
          - When you call `namedtuple`, you pass **(click)** in the name of the class and the attributes the class should have, and it'll dynamically create a new class for you
          - The **(click)** classes created by `namedtuple` have **(click)** a friendly string representation
          - **(click)** They can be compared to each other
          - And **(click)** they're immutable, and **(click)** hashable, just like tuples
          - So out-of-the-box, `namedtuple` pretty much gives us all the things we were looking for in our `Point` class
          - The **(click)** way we call `namedtuple` might seem a little unintuitive though
          - As of Python 3.5, there's an even better way to use `namedtuple`
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
from typing import NamedTuple

<span class="fragment" data-fragment-index=1><span class="fragment bold-current" data-fragment-index=4>class Point(NamedTuple)</span>:
    <span class="fragment bold-current" data-fragment-index=5>x: float <span class="fragment current-visible" data-fragment-index=6>= 0</span>
    y: float <span class="fragment current-visible" data-fragment-index=6>= 0</span>
    z: float <span class="fragment current-visible" data-fragment-index=6>= 0</span><span class="fragment" data-fragment-index=7></span></span></span>
        </code></pre>
        <pre class="python fragment" data-fragment-index=2><code data-trim data-noescape>
from collections import namedtuple

Point = <span class="fragment bold-current" data-fragment-index=3>namedtuple('Point', ['x', 'y', 'z'])</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - Instead of using `collections.namedtuple`, you can now **(click)** inherit from the `typing.NamedTuple` class which does the same thing
          - So while **(click)** `collections.namedtuple` is a **(click)** function that creates a class for you, **(click)** `typing.NamedTuple` is actually a class that you can inherit from
          - This `NamedTuple` class gives you pretty much the same thing as the `namedtuple` function except that we use type hints to make define its attributes
          - And you can specify default values for your attributes, which can be pretty handy in some cases
          - Though it probably doesn't make much sense in this example **(click)** 
          - *(pause)*
          - In general named tuples are a pretty great way to get something a bit more descriptive than the built-in tuple type
          - But if you're using named tuples to replace a class that doesn't need to work like a tuple, you might want to think twice.  Let me explain why.
        </aside>
      </section>

      <section>
        <h2>named<span class="fragment bold">tuple</span> are tuples</h2>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">Point(1, 2, 3) &lt; Point(4, 5, 6)
True
>>> </span><span class="fragment">Point(1, 2, 3) + Point(4, 5, 6)</span><span class="fragment">
(1, 2, 3, 4, 5, 6)
>>> </span><span class="fragment">Point(1, 2, 3) * 2</span><span class="fragment">
(1, 2, 3, 1, 2, 3)
>>> </span><span class="fragment">len(Point(1, 2, 3))
3</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - Named tuples inherit from tuples **(click)**
          - Which means they inherit all the features that tuples have
          - So they can be **(click)** ordered... which can be useful but sometimes it doesn't make sense, like in this case for example
          - They can also be **(click)** added to each other... but the tuple returned from this **(click)** might not be what you'd expect
          - The same is true for multiplication **(click)**
          - You can multiply namedtuples by integers, but the **(click)** thing you get back is a little odd
          - Also they have **(click)** a length... which also doesn't necessarily make sense in all cases
          - So named tuples can be useful, but you sometimes have to be careful while using them
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
from typing import NamedTuple

class Point(NamedTuple):
    x: float
    y: float
    z: float
    def __lt__(self, other): raise TypeError
    def __le__(self, other): raise TypeError
    def __gt__(self, other): raise TypeError
    def __ge__(self, other): raise TypeError
    def __add__(self, other): raise TypeError
    def __mul__(self, other): raise TypeError
    def __rmul__(self, other): raise TypeError
    def __len__(self, other): raise TypeError
        </code></pre>
        <aside class="notes" data-markdown>
          - You can fix these problems by overloading the appropriate operators in your named tuple class so that they all raise exceptions
          - But finding and removing features that you don't want is often trickier than adding features that you do want
          - If these features of named tuples are inappropriate for your use case, you probably shouldn't use them
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>attrs</h1>
        <aside class="notes" data-markdown>
          - One alternative to named tuples is `attrs`
          - `attrs` is a third-party library that makes it easier to create classes with certain common features
        </aside>
      </section>

      <section>
        <pre class="bash fragment"><code data-trim data-noescape>
$ pip install attrs
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
<span class="fragment bold-current">import attr</span>

<span class="fragment bold-current">@attr.s(auto_attribs=True)</span>
class Point:
    x: float
    y: float
    z: float<span class="fragment"></span>
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment">p
Point(x=1, y=2, z=3)
>>> </span><span class="fragment">p == Point(1, 2, 3)
True
>>> </span><span class="fragment">p &lt; Point(4, 5, 6)
True</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - You can get attrs by **(click)** pip-installing it
          - **(click)** After that you can use it by **(click)** importing attr (without the s, which is a little odd)
          - And then **(click)** decorating your class with the `attr.s` decorator
          - That `auto_attribs` argument allows us to use **(click)** type hints to define our attributes
          - By default, **(click)** `attrs` classes get **(click)** a nice string representation
          - And **(click)** they can be logically compared to other objects of the same type
          - But **(click)** they can also be ordered the same way named tuples can, which again is a bit odd in this case
          - If we want our `Point` class to work just like the one we made manually before, we could do this
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
import attr

@attr.s(auto_attribs=True, <span class="fragment bold-current" data-fragment-index=3>cmp=False</span>, <span class="fragment bold-current" data-fragment-index=1>frozen=True</span>)
class Point:
    x: float
    y: float
    z: float
    <span class="fragment bold-current" data-fragment-index=2>def __iter__(self):
        yield from (self.x, self.y, self.z)</span>
    <span class="fragment bold-current" data-fragment-index=4>def __eq__(self, other):
        if not isinstance(other, Point):
            return NotImplemented
        return tuple(self) == tuple(other)</span>
    <span class="fragment bold-current" data-fragment-index=5>def __hash__(self):
        return hash(tuple(self))</span><span class="fragment" data-fragment-index=10></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - Here we've **(click)** frozen our object so the attributes can't be modified
          - We've also added **(click)** a dunder iter method to make our object work with multiple assignment
          - And we've **(click)** disabled comparisons so we don't get automatic ordering, but that means we need to implement **(click)** a dunder eq method
          - We also need to implement **(click)** a dunder hash method ourselves
          - Normally we would get that for free with frozen classes, but disabling comparisons also disables hashing by default **(click)**
          - So the attrs library is more powerful than named tuples, but it does sometimes take a bit of playing to get it just right
          - Also it's a third party library which means you'll need to install it whenever you want to use it
          - There's something similar to `attrs` that's actually bundled with Python though
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>dataclasses</h1>
        <aside class="notes" data-markdown>
          - Data classes is essentially a simplified version of the `attrs` library that's built-in to the Python standard library
        </aside>
      </section>

      <section data-transition="none-out" data-transition-speed="default-in fast-out">
        <pre class="python"><code data-trim data-noescape>
<span class="fragment bold-current">from dataclasses import dataclass</span>

<span class="fragment bold-current">@dataclass</span>
class Point:
    <span class="fragment bold-current">x: float</span>
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> <span class="fragment">p = Point(1, 2, 3)
>>> </span><span class="fragment">p
Point(x=1, y=2, z=3)
>>> </span><span class="fragment">p == Point(1, 2, 3)
True
>>> </span><span class="fragment">p &lt; Point(4, 5, 6)
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: '&lt;' not supported between instances of 'Point' and 'Point'</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - To use dataclasses, you'll **(click)** import `dataclass` from the `dataclasses` library
          - And you'll **(click)** decorate your class, the same way you can with `attrs`
          - The syntax relies on **(click)** type hinting, just like `typing.NamedTuple` and `attrs` do
          - This **(click)** `Point` class has **(click)** a nice string representation and **(click)** it supports comparisons
          - But **(click)** it doesn't support ordering... and that's perfect because we don't want our class to orderable
          - But this `Point` class doesn't work quite the way we want it to yet
        </aside>
      </section>

      <section data-transition="none-in none-out" data-transition-speed="fast-in default-out">
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> p = Point(1, 2, 3)
>>> <span class="fragment">x, y, z = p
</span><span class="fragment">Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: cannot unpack non-iterable Point object
>>> </span><span class="fragment">p.x = 4</span><span class="fragment">
>>> p
Point(x=4, y=2, z=3)

</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - If we try to use this point with multiple assignment **(click)**, we'll get an error **(click)**, because our `Point` class is not iterable so we can't unpack into 3 variables
          - Also if we **(click)** try to assign to the `x` attribute in our class
          - It **(click)** works... which isn't good because our class is *supposed to be* **immutable**, meaning we shouldn't be able to change the attributes in our `Point` objects
          - We're expecting to get an error here instead
          - So we need to make our `Point` class iterable and immutable
        </aside>
      </section>

      <section data-transition="none-out" data-transition-speed="default-in fast-out">
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
    z: float
    <span class="fragment">def __iter__(self):
        yield from <span class="fragment bold-current">(self.x, self.y, self.z)</span></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - To make our class iterable, we can add **(click)** a dunder iter method
          - Which you could copy-paste from the Point class that we made manually earlier, before we looked at namedtuples and attrs and dataclasses
          - But instead of hard-coding **(click)** self.x, self.y, and self.z, you could instead copy-paste this code
          - *(pause)*
        </aside>
      </section>

      <section data-transition="none-in none-out" data-transition-speed="fast-in fast-out">
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, astuple

@dataclass<span class="fragment" data-fragment-index=4><strong>(frozen=True)</strong></span>
class Point:
    x: float
    y: float
    z: float
    def __iter__(self):
        yield from astuple(self)
        </code></pre>
        <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment" data-fragment-index=2>x, y, z = p
>>> </span><span class="fragment" data-fragment-index=3>x
1
>>> y
2</span></code></pre>

        <aside class="notes" data-markdown>
          - The `dataclasses` library has an `astuple` helper that allows us to get a tuple that contains our object's attributes without manually specifying each of the attributes.  Which is kind of nifty.
          - *(pause)*
          - So our **(click)** `Point` class is iterable now, meaning we can use **(click)** multiple assignment with it
          - Which is great **(click)**
          - But it's not immutable yet
          - To make it immutable, we can set the **(click)** `frozen` attribute when using our `dataclass` decorator
        </aside>
      </section>

      <section data-transition="none-out" data-transition-speed="fast-in default-out">
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, astuple

@dataclass(frozen=True)
class Point:
    x: float
    y: float
    z: float
    def __iter__(self):
        yield from astuple(self)
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment" data-fragment-index=5>p.x = 4</span><span class="fragment">
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 3, in __setattr__
dataclasses.FrozenInstanceError: cannot assign to field 'x'</span>
        </code></pre>

        <aside class="notes" data-markdown>
          - Now that we've frozen our `Point` class, if we **(click)** try to assign an attribute on a point object, **(click)**, we'll get an error
          - Which is just what we're looking for
          - So our class is now iterable, immutable, comparable, and it has a nice representation.  But it's *not* orderable, it *doesn't have a length, and it *doesn't* have other features that don't make sense either
          - So using dataclasses, we've made a **friendly class** that has just the features that we want
          - All in less than 10 lines of code.  I think this is pretty cool.
        </aside>
      </section>


      <section>
        <h2>dataclasses</h2>
        <ul>
          <li class="fragment">Built-in to standard library <span class="fragment">(in Python 3.7)</span></li>
          <li class="fragment">Available as a third-party library</li>
          <li class="fragment">dataclasses is simpler, but less feature-rich than attrs</li>
          <li class="fragment">While attrs supports both Python 2 and Python 3, dataclasses only work on Python 3</li>
        </ul>
        <aside class="notes" data-markdown>
          - When I told you before that dataclasses are **(click)** included in the Python standard library, I meant that **(click)** it's included with Python 3.7
          - Which was just released pretty recently, so you're probably not using it yet
          - It's also **(click)** available as a third-party library though, so you can pip-install it from any version of Python 3.  If you're on Python 2, you're out of luck.
          - If you need Python 2 support **(click)** or if you need **(click)** more features than dataclasses provide, you might want to reach for the `attrs` library instead
          - The dataclasses library was partially inspired attrs, so many of the design decisions made by each are similar
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h1>Data Classes Recipes</h1>
        <aside class="notes" data-markdown>
          - Let's take a look at some common uses for data classes
        </aside>
      </section>

      <section>
        <h2>What you get out of the box</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> p
Point(x=1, y=2, z=3)
>>> p == Point(1, 2, 3)
True
        </code></pre>
        <aside class="notes" data-markdown>
          - Without any other customization, data classes give you:
            - a good string representation for your object
            - and they allow you to compare objects to each other with the equality and inequality operators
        </aside>
      </section>

      <section>
        <h2>Immutability?</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment">p.x = 8
>>> </span><span class="fragment">p.x
8
>>> </span><span class="fragment">p
Point(x=8, y=5, z=3)</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - By default, dataclasses are mutable, meaning that you can change their values
          - That's often the functionality that's most useful, but if you wanted an immutable class, one that you can't change, you can do that too
        </aside>
      </section>

      <section>
        <h2>Immutability!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass<span class="fragment bold-current">(frozen=True)</span>
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment">p.x = 4
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 3, in __setattr__
dataclasses.FrozenInstanceError: cannot assign to field 'x'</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - As we've already seen, the `frozen` argument can be passed to the `dataclass` decorator to make our data classes immutable
          - This will make it so we can't assign to any of the attributes in our class after it's been constructed
        </aside>
      </section>

      <section>
        <h2>Hashability!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass(frozen=True)
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> q = Point(4, 5, 6)
>>> r = Point(1, 2, 3)
>>> <span class="fragment">points = {p, q, r}
>>> </span><span class="fragment">points
{Point(x=4, y=5, z=6), Point(x=1, y=2, z=3)}</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - As an added bonus, frozen dataclasses are also hashable by default
          - Meaning we can use our objects in sets and as dictionary keys
          - Normally dataclasses aren't hashable because it's usually a bad idea to allow mutable objects to be hashable
        </aside>
      </section>

      <section>
        <h2>Iterability?</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Point(1, 2, 3)
>>> <span class="fragment">x, y, z = p
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'Point' object is not iterable</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - By default, you can't unpack a dataclass
          - If we want to use multiple assignment with dataclasses, we'll need to implement our own dunder iter method
        </aside>
      </section>

      <section>
        <h2>Iterability!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Point:
    x: float
    y: float
    z: float
    def __iter__(self):
        yield self.x
        yield self.y
        yield self.z
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> x, y, z = Point(1, 2, 3)
</code></pre>
        <aside class="notes" data-markdown>
          - As we've already seen, we can do that manually by yielding x, y, and z individually
          - The dataclasses library also includes helpers to make looping over our fields easier
        </aside>
      </section>

      <section>
        <h2>Better Iterability!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, astuple

@dataclass
class Point:
    x: float
    y: float
    z: float
    def __iter__(self):
        yield from astuple(self)
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> x, y, z = Point(1, 2, 3)
>>> (x, y, z)
(1, 2, 3)
        </code></pre>
        <aside class="notes" data-markdown>
          - The `astuple` function accepts a dataclass and returns a tuple of its attribute values, in order
          - So we yield items from this tuple instead of writing each attribute out manually
        </aside>
      </section>

      <section>
        <h2>Orderability?</h2>
        <pre class=""><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class Month:
    year: int
    month: int
        </code></pre>
        <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> eol_month = Month(2020, 1)
>>> eol_month
Month(year=2020, month=1)
>>> <span class="fragment">eol_month > Month(2019, 12)</span>
<span class="fragment">Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: '>' not supported between instances of 'Month' and 'Month'</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - What if we want our objects to be orderable using the less than and greater than operators?
          - By default, we can only check for equality and inequality on our classes
          - They don't support ordering automatically
        </aside>
      </section>

      <section>
        <h2>Orderability!</h2>
        <pre class=""><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass<span class="fragment bold-current">(order=True)</span>
class Month:
    year: int
    month: int
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> Month(2020, 1) > Month(2019, 12)
True
>>> months = [Month(2018, 6), Month(2018, 1), Month(2019, 10)]
>>> <span class="fragment">print(*sorted(months), sep='\n')
Month(year=2018, month=1)
Month(year=2018, month=6)
Month(year=2019, month=10)</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - But if we do want to support ordering, we can pass the `order` argument to the `dataclass` decorator when we make our class
          - Our class will be ordered lexicographically, the same way tuples, lists, and strings are ordered in Python
        </aside>
      </section>

      <section>
        <h2>Summability and other operations?</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, astuple

@dataclass
class Vector:
    x: float
    y: float
    z: float
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> p = Vector(1, 2, 3)
>>> q = Vector(4, 5, 6)
>>> <span class="fragment">p + q
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: unsupported operand type(s) for +: 'Vector' and 'Vector'
>>> <span><span class="fragment">q - p
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: unsupported operand type(s) for +: 'Vector' and 'Vector'</span></code></pre>
        <aside class="notes" data-markdown>
          - What if you want other operations on your objects?
          - By default, dataclasses don't support the `+` operator and they don't support the `-` operator
          - If you want your classes to work with these operators, you'll have to implement that suppot yourself
        </aside>
      </section>

      <section>
        <h2>Summability and other operations!</h2>
        <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass, astuple

@dataclass
class Vector:
    x: float
    y: float
    z: float
    def __iter__(self):
        yield from astuple(self)
    def __add__(self, other):
        return Vector(*(a + b for a, b in zip(self, other)))
    def __sub__(self, other):
        return Vector(*(a - b for a, b in zip(self, other)))        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">Vector(1, 2, 3) + Vector(4, 5, 6)
Vector(x=5, y=7, z=9)
>>> </span><span class="fragment">Vector(4, 5, 6) - Vector(1, 2, 3)
Vector(x=3, y=3, z=3)</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - But if you make your classes iterable, it's not that hard
          - Here we've implemented dunder add and dunder sub methods for addition and subtraction
          - Instead of manually adding x, y, and z coordinates, we're delegating work to our dunder iter method, which is in turn delegating work to the `astuple` helper function
        </aside>
      </section>

      </section>

      <section>
        <h2>When making classes, consider...</h2>
        <ul>
          <li class="fragment">You don't always need custom classes for your data <nobr class="fragment">(see Jack Diederich's <a href="https://www.youtube.com/watch?v=o9pEzgHorH0">Stop Writing Classes</a>)</nobr></li>
          <li class="fragment">Custom can make things very handy, but they can be a step down unless you make them friendly to use</li>
          <li class="fragment">Friendly classes can require a lot of boilerplate code</li>
          <li class="fragment">To avoid distracting boilerplate code, use <code>dataclasses</code> <span class="fragment">or <code>attrs</code> for creating custom data-heavy classes</span></li>
        </ul>
        <aside class="notes" data-markdown>
          - When you're about to create a class in Python, I'd like you to consider
          - That you probably don't need a class
          - There's a talk called Stop Writing Classes that I'd highly recommend watching if you haven't seen it before
          - If you do decide you need a class, you should make it a friendly one.  Using your class should feel almost as natural as using one of the Python built-in data types
          - Creating a friendly class involves writing a lot of boilerplate code
          - But the dataclasses library can help with this
          - If you're on Python 3.7, it comes bundled with Python. If you're on an earlier version of Python 3, you can pip-install it.
          - And if dataclasses isn't enough for you, or if you need Python 2 support, there's always the attrs library
        </aside>
      </section>

      <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
        <h2>Need help getting your team <nobr>up to speed on Python?</nobr></h2>
        <h3>
          <strong>Trey Hunner</strong><br>
          <small>Python &amp; Django Team Trainer</small>
        </h3>
        <p>
          <small>
            Contact me: <a href="mailto:&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;">&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;</a>
          </small>
        </p>
        <p>
        <a href="http://truthful.technology"><img src="logo.svg" class="no-style logo"></a>
        <a href="http://pythonmorsels.com"><img src="python-morsels-logo.svg" class="no-style logo"></a>
        </p>
        <aside class="notes" data-markdown>
          - My name is Trey Hunner
          - I would love to teach Python and Django at your company
          - Feel free to shoot me an email
          - Thank you!
        </aside>
      </section>


      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/truthful.js"></script>


    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
